package lt5

import "fmt"

// 最长回文子串

//给定一个字符串 s，找到 s 中最长的回文子串。
// 你可以假设 s 的最大长度为 1000。

//输入: "babad"
// 输出: "bab"
// 注意: "aba" 也是一个有效答案。

// 思考：
// 纯暴力：遍历所有可能的字符串，检查其是不是回文串。时间复杂度O(k^2 * k) ， k为字符串长度
// 比暴力稍好：由于是寻找最长的回文子串，则可以直接遍历字符串s，寻找以当前
// 		字母为中心（或者左中心）的最长的回文子串。这样做的时间复杂度为O(k*k)
//
// 第二种解法仍然没有利用线性遍历时前面字符已检查过的特性，但看上去还行，先实现它

// 左中心：回文子串长度有可能是偶数，如果是偶数，中间会有两个字符，这里称作左右中心，
// 一律检查当前字符作为左中心的情况

// 遍历字符串s，以每个字母为回文串中心或左中心，找最长的回文串
func longestPalindrome(s string) string {
	n := len(s)
	if n < 2 {
		return s
	}

	var longest string // 最长回文串
	l := 0             // 最长回文子串长度

	for i := 0; i < n; i++ {

		//fmt.Println(l, longest, i)

		// 以当前字符作为中心，进行尝试
		j := 1
		for i-j >= 0 && i+j < n { // j是除中心外的子串长度的一半
			if s[i-j] == s[i+j] {
				j++
			} else {
				break
			}
		} // 注意出来后j会加一，因此回文子串长度为2j-1而不是2j+1
		if 2*j-1 > l {
			l = 2*j - 1
			longest = s[i-j+1 : i+j]
		}

		//fmt.Println(l, longest, i)

		// 以当前字符作为左中心，进行尝试
		j = 1
		for i-j+1 >= 0 && i+j < n { // j是包括左中心的子串长度的一半
			if s[i-j+1] == s[i+j] {
				fmt.Println(j)
				j++
			} else {
				break
			}
		} // 注意出来后j会加一，因此回文子串长度为2j-2而不是2j
		//fmt.Println("j=", j)
		if 2*j-2 > l {
			l = 2*j - 2
			longest = s[i-j+2 : i+j]
		}
	}

	return longest
}

// 看了下题解区，我这种解法就是中心扩展法，相对较优。题解区有一种“马拉车解法”，实现了O(n)的时间复杂度，实在厉害
// 以后再学。

// 其实这里中心扩展的过程可以进行优化：
// 在外层i的循环末尾加上一句判断： if n-i-1 < l {break}
// 因为再往后遍历是没有意义的。
// 按照这个思路，其实i从中间开始遍历是最优的，可以在两端都作上面的提前退出的优化
// 只是这样，代码要增加一些。
