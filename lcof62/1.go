package lcof62

// ## 7. 圆圈中最后剩下的数字

// 0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

// 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

// 这道题是一个约瑟夫环形问题，与环形链表密切相关。

// 当然做题的时候并不一定需要构建环形链表

// 首先，脑海里要抽象出（或者在纸上画出）一个结点数量为n的一个环，删除第m个数字，那么就是删除
// 第m%n个数字。

// 其次，假如说不使用数据结构记录删除一些数之后数列的状态，那么是没办法解这道题的。

// 因此需要采用数组来存储0~n-1。使用数组有个好处是可以方便的通过`m%n`来索引某个元素

// 但是因为需要不断删除元素，数组需要不断的缩小，这意味着比较多的数据搬迁。

// 使用环形链表删除元素优化了，但是获取下一个元素却需要遍历。

// 两种结构存储都可以，但各有优劣。

// 下面使用数组记录数据，解决这道题

func lastRemaining(n int, m int) int {
	// 初始环
	ring := make([]int, n)
	for i := 0; i < n; i++ {
		ring[i] = i
	}

	//  循环删除
	idx := 0
	for len(ring) > 1 {
		idx = (idx + m) % len(ring)
		ring = append(ring[:idx], ring[idx+1:]...)
	}
	return ring[0]
}

// 事实上，提交后，无论是使用数组还是使用链表来模拟进行删除步骤，都是会超时的。

// 能够通过的解法是数学解法，

// 把问题考虑成n个人成环的问题，序号分别为 ：
// $$0,1,2,...,n-1$$
// 考虑第一次从0开始找到第m个人出圈(m可能比n大，所以使用$k=(m-1)\%n$)，现在序号变成了：
// $$0,1,2,..., k-1, k+1, ... ,n-1$$
// 现在出发点为k+1这号，把k+1后面的移到序列前部，得到：
// $$k+1, ... ,n-1,0,1,2,..., k-1$$
// 显然，可以将之映射为：
// $$0,1,2,..., (n-1)-(k+1), n-k+-1, ... ,n-2$$
// 记原始数字为x，映射后的数字为y，两者的转换：
// $$x = (y + (k+1)) \% n$$

// 对于题目的n个数字形成的圆圈，以及不断删除第m个数字，因此把最后剩下的数字记作$f(n,m)$

// 那么假设n个数字删掉一个变成n-1个后，最后剩下的那个数字就可以表示为$f(n-1,m)$

// 那么把该符号代到x,y的转换公式，得到最后剩下的原始数字为$(f(n-1,m) + (k+1)) \% n$

// 而这个数字也就是最开始的$f(n,m)$，于是代入下式：
// $$f(n,m) = (f(n-1,m) + (k+1)) \% n$$
// 得到：
// $$f(n,m) = (f(n-1,m) + k +1) \% n$$
// 得到：
// $$f(n,m) = (f(n-1,m) + (m-1)\%n +1) \% n$$
// 根据数学性质：
// $$(a\%n+b)\%n = (a+b)\%n$$
// 所以上式继续得到：
// $$f(n,m) = (f(n-1,m) + m-1 +1) \% n$$
// 即
// $$f(n,m) = (f(n-1,m) + m) \% n$$
// 并且初始有 $f(1,m)=0$

// 好了，到这，其实就是个动态规划，这个动态规划可以用迭代或者递归实现。

func lastRemaining2(n int, m int) int {
	last := 0 // 初始位是0,(f(1,m)=0)
	for i := 2; i <= n; i++ {
		last = (last + m) % i
	}
	return last
}
