package lcci0806

// 程序员面试金典 08.06

// 汉诺塔问题

//在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
//(1) 每次只能移动一个盘子;
//(2) 盘子只能从柱子顶端滑出移到下一根柱子;
//(3) 盘子只能叠在比它大的盘子上。
//
//请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
//
//你需要原地修改栈。
//
//示例1:
//
// 输入：A = [2, 1, 0], B = [], C = []
// 输出：C = [2, 1, 0]
//示例2:
//
// 输入：A = [1, 0], B = [], C = []
// 输出：C = [1, 0]
//提示:
//
//A中盘子的数目不大于14个。
//
//来源：力扣（LeetCode）
//链接：https://leetcode-cn.com/problems/hanota-lcci
//著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

// n个盘子移到C <=> 把


func hanota(A *[]int, B *[]int, C *[]int)  {
	n := len(*A)
	if n == 0 {return}

	// 将n个盘子，从A 经过B(以B作为辅助) 放到C
	move(n, A, B, C)
}

// 将n个盘子从A经过B移去C。
func move(n int, A,B,C *[]int) {
	if n == 1 {
		// 直接将盘子从A移到C
		*C = append(*C, (*A)[len(*A)-1])	// 将A末尾追加到C末尾
		*A = (*A)[:len(*A)-1]	// A缩小
		return
	}

	// 否则的话，需要先将A中最大盘子上面的盘子(n-1个盘子) 经过 C 移动到 B
	move(n-1, A, C, B)
	// 然后再将A剩下的唯一盘子移到C
	*C = append(*C, (*A)[len(*A)-1])	// 将A末尾追加到C末尾
	*A = (*A)[:len(*A)-1]	// A缩小
	// 再将B上的这些盘子 经过A 挪到C
	move(n-1, B, A, C)
}
