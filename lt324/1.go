package lt324

import "sort"

// 摆动排序II


// 这个题目最难的点在于
// 存在重复元素甚至是连续重复元素
// 而要求的是严格的><大小关系


//// 思考：
//// 使用指针p,q从前向后。 p指0,2,4..， q指1,3,5..
//// 显然在p,q后移的过程中应该保证nums[p1]<nums[q], nums[q]>nums[p2]
//// p, q = 0, 1。
//// if nums[p] < nums[q]  { p++,q++ } else {交换}
////
//
//func wiggleSort(nums []int)  {
//	n := len(nums)
//
//	p, q := 0, 1
//	for p<n && q<n {	// 不判断n奇偶的情况下，只能用两个都<n来防止出界
//		// 1. 先保证
//	}
//}


// 不过多浪费时间思考，上题解区

// 不得不说一句，果然这道题公认的很难...


// 1. 排序后反序交插  O(nlogn)/O(n)
func wiggleSort1(nums []int)  {
	n := len(nums)

	// 1. 升序排序(降序也可以，相应调整就好)
	sort.Ints(nums)
	// 假设排序后得到数组 [4,5<1>,5<2>,6]。 较小一半A=[4,5<1>]，较大一半B=[5<2>，6]
	// 如果直接分两半交插会得到 [4,5<2>,5<1>,6]。显然不符合题目的要求
	// 考虑反序交插，也就是A=[5<1>, 4], B=[6,5<2>]，交插后 [5<1>, 6, 5<2>, 4] 符合要求
	// 数学证明略，各种情况(n奇偶)都手推一下

	// 2. 划分A，B数组(smaller, bigger)
	la, lb := n/2, n/2
	if n%2 == 1 {la = n/2 + 1}		// n为奇数时A多一个
	A, B := append([]int{}, nums[:la]...), append([]int{}, nums[la:]...)

	// 3. 反序交插
	for i:=0; i<lb; i++ {
		nums[2*i] = A[la-1-i]
		nums[2*i+1] = B[lb-1-i]
	}
	if la>lb {nums[n-1] = A[0]}
}


// 这道题进阶要求O(n)/O(1)实现。
// 先留着...

