package main

import "fmt"

// 摩斯密码

// 0代表停顿
// 1个0代表字符内的停顿
// 3个代表字符间
// 6个代表单词间停顿

func main() {
	var in string
	fmt.Scan(&in)
	ans := sol(in)
	fmt.Println(ans)
}

var m2 = map[string]byte{
	"10111": 'A',
	"111010101": 'B',
	"11101011101": 'C',
	"1110101": 'D',
	"1": 'E',
	"101011101": 'F',
	"111011101": 'G',
	"1010101": 'H',
	"101": 'I',
	"1011101110111": 'J',
	"111010111": 'K',
	"101110101": 'L',
	"1110111": 'M',
	"11101": 'N',
	"11101110111": 'O',
	"10111011101": 'P',
	"1110111010111": 'Q',
	"1011101": 'R',
	"10101": 'S',
	"111": 'T',
	"1010111": 'U',
	"101010111": 'V',
	"101110111": 'W',
	"11101010111": 'X',
	"1110101110111": 'Y',
	"11101110101": 'Z',
	"10111011101110111": '1',
	"101011101110111": '2',
	"1010101110111": '3',
	"10101010111": '4',
	"101010101": '5',
	"11101010101": '6',
	"1110111010101": '7',
	"111011101110101": '8',
	"11101110111011101": '9',
	"1110111011101110111": '0',
}

func sol(mos string) string {
	if len(mos) == 0 {return ""}

	ans := make([]byte, 0)

	prev0End := -1
	start0 := -1	// 连续'0'的起点前1个
	// 只统计0的起始位置
	if mos[0] == '0' {
		start0 = 0
	}


	for i:=1; i<len(mos); i++ {
		if mos[i] == '0' {
			if mos[i-1] == '0' {
				// 继续后移
			} else {
				start0 = i-1
			}
		} else {	// == '1'
			if mos[i-1] == '1' {
				// 不管
			} else {	// == '0'
				// 计数之前的'0'
				count := i-1 - start0
				switch count {
				case 1:
					// 不管
				case 3:
					// 转换字符
					ans = append(ans, m2[mos[prev0End:start0]])

				case 6:
					ans = append(ans, ' ')
				}
			}
		}
	}
	return string(ans)
}
